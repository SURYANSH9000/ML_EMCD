# -*- coding: utf-8 -*-
"""designCredit.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WbFmPkTmkk4qzKWtnBL9Y8uJvrLeLKFf
"""

import numpy as np
import pandas as pd
import csv
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.cluster import KMeans
from sklearn.linear_model import LinearRegression
from sklearn.decomposition import PCA
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score

# Define the file names as a list
file_names = ['48_16.csv', '48_20.csv', '48_24.csv', '48_28.csv', '48_32.csv', '52_16.csv', '52_20.csv', '52_24.csv', '52_28.csv', '52_32.csv', '56_16.csv', '56_20.csv', '56_24.csv', '56_28.csv', '56_32.csv', '60_16.csv', '60_20.csv', '60_24.csv', '60_28.csv', '60_32.csv', '64_16.csv', '64_20.csv', '64_24.csv', '64_28.csv', '64_32.csv']

# Define an empty list to store the last column of each file
last_cols = []

# Loop over each file and extract the last column
for file_name in file_names:
    # Read the csv file
    df = pd.read_csv(file_name,header=None,sep='  ')
    last_col = df.iloc[:, -1]
    # print(f"Number of data points in {file_name}: {len(last_col)}")
    # Append the last column to the list
    last_cols.append(last_col)

first_len = len(last_cols[0]) 
matrix_size = np.sqrt(first_len)
# print(first_len)
reverse_list = last_cols[::-1]

matrix = []

for arr in reverse_list:
  arr = np.array(arr)
  # print(len(arr))
  matrix.append(arr.reshape(26,26))

# Create a grid of 5x5 subplots
fig, axs = plt.subplots(nrows=5, ncols=5, figsize=(20, 20))

# Plot each matrix in a subplot
for i, ax in enumerate(axs.flat):
    if i < 25:
        im = ax.imshow(matrix[i])
        ax.set_title(file_names[i])
        if i % 5 != 0:
            ax.set_yticks([])
        if i < 20:
            ax.set_xticks([])
        else:
            ax.set_xlabel('x')
            ax.set_ylabel('y')

plt.tight_layout()
plt.show()

reverse_list = last_cols[::-1]
matrix = []

for arr in reverse_list:
    arr = np.array(arr)
    matrix.append(arr.reshape(26, 26))

# Create a grid of 5x9 subplots
fig, axs = plt.subplots(nrows=5, ncols=9, figsize=(20, 12))

# Plot each matrix in a subplot
for i in range(5):
    for j in range(9):
        if j < 5:
            # plot figures normally in the first 5 columns
            k = i * 5 + j
        else:
            # plot mirrored figures in the last 4 columns
            k = i * 5 + (8 - j)
        
        # invert the image if the column index is greater than 5
        if j >= 5:
            matrix[k] = np.flipud(matrix[k])
        
        # plot the figure
        im = axs[i, j].imshow(matrix[k])
        axs[i, j].set_title(file_names[k])
        
        # hide tick labels for inner subplots
        if i != 4:
            axs[i, j].set_xticks([])
        if j != 0:
            axs[i, j].set_yticks([])

# Add x and y labels for the outer subplots
for ax in axs[4, :]:
    ax.set_xlabel('x')
for ax in axs[:, 0]:
    ax.set_ylabel('y')

plt.tight_layout()
plt.show()

reverse_list = last_cols[::-1]
matrix = []

for arr in reverse_list:
    arr = np.array(arr)
    matrix.append(arr.reshape(26, 26))

# Create a grid of 9x9 subplots
fig, axs = plt.subplots(nrows=9, ncols=9, figsize=(20, 20))

# Plot each matrix in a subplot
for i in range(9):
    if i < 4:
        # plot figures normally in the first 4 rows
        row_index = i
    else:
        # plot mirrored figures in the last 4 rows
        row_index = 8 - i
        
    for j in range(9):
        if j < 5:
            # plot figures normally in the first 5 columns
            col_index = j
        else:
            # plot mirrored figures in the last 4 columns
            col_index = 8 - j
            matrix[row_index * 5 + col_index] = np.flipud(matrix[row_index * 5 + col_index])
        
        # invert the image if the row index is greater than or equal to 4
        if i > 4:
            matrix[row_index * 5 + col_index] = np.flipud(matrix[row_index * 5 + col_index])
            half = matrix[row_index * 5 + col_index].shape[1] // 2
            left = matrix[row_index * 5 + col_index][:, :half]
            right = matrix[row_index * 5 + col_index][:, half:]
            matrix[row_index * 5 + col_index] = np.concatenate([right, left], axis=1)
        # plot the figure
        im = axs[i, j].imshow(matrix[row_index * 5 + col_index])
        
        # set title for the figure
        if i == 0:
            axs[i, j].set_title(file_names[col_index])
        elif j == 0:
            axs[i, j].set_ylabel(file_names[row_index * 5], rotation=0, size='large')
            axs[i, j].yaxis.set_label_coords(-0.7, 0.5)
        
        # hide tick labels for inner subplots
        if i != 8:
            axs[i, j].set_xticks([])
        if j != 0:
            axs[i, j].set_yticks([])

# Add x and y labels for the outer subplots
for ax in axs[8, :]:
    ax.set_xlabel('x')
for ax in axs[:, 0]:
    ax.set_ylabel('y')

plt.tight_layout()
plt.show()

for arr in reverse_list:
  arr = np.array(arr)
  # print(len(arr))
  matrix.append(arr.reshape(26,26))

# Convert the matrix to a numpy array
X = np.array(matrix)

# Reshape the data to be a 2D array
X_2d = X.reshape((X.shape[0], -1))

# Perform clustering with KMeans
kmeans = KMeans(n_clusters=5, random_state=0).fit(X_2d)

# Plot the clustered data
plt.scatter(X_2d[:, 0], X_2d[:, 1], c=kmeans.labels_)
plt.show()

# Create a grid of 5x5 subplots
fig, axs = plt.subplots(nrows=5, ncols=5, figsize=(20, 20))

# Plot each matrix in a subplot
for i, ax in enumerate(axs.flat):
    if i < 25:
        im = ax.imshow(matrix[i])
        ax.set_title(file_names[i])
        if i % 5 != 0:
            ax.set_yticks([])
        if i < 20:
            ax.set_xticks([])
        else:
            ax.set_xlabel('x')
            ax.set_ylabel('y')

plt.tight_layout()
plt.show()

# Create a matrix from the last columns of the CSV files
matrix = np.vstack(last_cols).T

# Define the x and y variables
x = matrix[:, :-1]
y = matrix[:, -1]

# Define the regression model
reg = LinearRegression().fit(x, y)

# Print the R-squared value
print('R-squared value:', reg.score(x, y))

# Apply MinMaxScaler to normalize the matrix
scaler = MinMaxScaler()
normalized_matrix = scaler.fit_transform(matrix)

# Apply PCA to reduce the dimensionality of the matrix
pca = PCA(n_components=2)
reduced_matrix = pca.fit_transform(normalized_matrix)

# Create a scatter plot of the reduced matrix
plt.scatter(reduced_matrix[:, 0], reduced_matrix[:, 1])
plt.title('PCA - Dimensionality Reduction')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.show()